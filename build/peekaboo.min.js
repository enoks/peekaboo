/**
 * peekaboo v1.1.2
 * https://github.com/enoks/peekaboo.js
 *
 * Copyright 2017, Stefan KÃ¤sche
 * https://github.com/enoks
 *
 * Licensed under GNU GENERAL PUBLIC LICENSE Version 3
 * https://github.com/enoks/peekaboo.js/blob/master/LICENSE
 */
!function(e,t){"use strict";"function"==typeof define&&define.amd?define("peekaboo",[],function(){return t}):"object"==typeof module&&"object"==typeof module.exports?module.exports=t:window.peekaboo=t}(this,function(){"use strict";function e(e){if(t.length&&!o){o=!0;var n=window.pageYOffset,i=n+Math.max(document.documentElement.clientHeight,window.innerHeight||0),l=window.pageXOffset,a=l+Math.max(document.documentElement.clientWidth,window.innerWidth||0);t.forEach(function(o,s){"number"==typeof e&&e!==s||(o.$.forEach(function(e,t){if(!e)return delete o.$[t];var s=e.getBoundingClientRect().top+window.pageYOffset-document.documentElement.clientTop,c=s+e.clientHeight,r=e.getBoundingClientRect().left+window.pageXOffset-document.documentElement.clientLeft,d=r+e.clientWidth;(o.options.loadInvisible===!0||("vertical"==o.options.loadInvisible||c>=n-o.options.threshold&&s<=i+o.options.threshold)&&("horizontal"==o.options.loadInvisible||d>=l-o.options.threshold&&r<=a+o.options.threshold))&&(o.options.class&&e.className.indexOf(o.options.class)<0&&(e.className+=" "+o.options.class),o.options.callback.call(e,o.options),delete o.$[t])}),(o.$=o.$.filter(function(e){return e}))&&!o.$.length&&t.splice(e,1))}),setTimeout(function(){o=!1},200)}}var t=[],o=!1;return window.addEventListener("load",e),window.addEventListener("scroll",e),window.addEventListener("resize",e),function(o,n){if(o&&("string"==typeof o?o=document.querySelectorAll(o):o instanceof HTMLElement&&(o=[o]),o.length)){o=Array.prototype.slice.call(o),"function"==typeof n&&(n={callback:n});var i={threshold:0,loadInvisible:!1,class:"peekaboo",callback:function(e){}};if("[object Object]"===Object.prototype.toString.call(n))for(var l in n)if(n.hasOwnProperty(l)){if("loadInvisible"==l)switch((n[l]+"").toLowerCase()){case"true":case"1":n[l]=!0;break;case"horizontal":case"x":n[l]="horizontal";break;case"vertical":case"y":n[l]="vertical";break;default:continue}else switch(typeof i[l]){case"undefined":break;default:if(typeof i[l]!=typeof n[l]){console.debug("Passed value for option '"+l+"' (type of "+typeof n[l]+") doesn't match expected value type ("+typeof i[l]+").");continue}break;case"number":if(n[l]=parseFloat(n[l]),isNaN(n[l])){console.debug("Passed value for option '"+l+"' isn't of type number at all.");continue}}i[l]=n[l]}t.push({$:o,options:i}),e(t.length-1)}}}());